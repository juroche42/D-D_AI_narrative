# US-02-02 — Connexion utilisateur (NextAuth v5)

## Vue d'ensemble

Cette US implémente le système d'authentification complet du projet D&D AI Narrative : connexion par Credentials via **NextAuth v5 (Auth.js beta)**, sessions JWT, protection de routes via `proxy.ts`, et un formulaire de connexion avec le même thème dark/rouge qu'US-02-01.

---

## Architecture

```
lib/
├── auth/
│   ├── auth.config.ts        ← Config légère (authorized callback, pages, JWT strategy)
│   ├── auth.ts               ← NextAuth complet avec Credentials provider + Prisma + bcrypt
│   └── index.ts              ← Barrel : handlers, auth, signIn, signOut
│
├── validations/
│   └── auth.ts               ← Ajout : LoginSchema + LoginInput
│
└── services/auth/
    └── authService.ts        ← Ajout : loginUser()

types/
└── next-auth.d.ts            ← Augmentation TypeScript : session.user.id + username

proxy.ts                      ← Intégration NextAuth + CORS + logging (matcher étendu)

app/
├── providers.tsx             ← 'use client' — SessionProvider wrapper
├── layout.tsx                ← Wrappé avec <Providers>
├── (auth)/login/
│   ├── page.tsx              ← Server Component
│   └── actions.ts            ← Server Action : loginAction()
└── api/auth/
    ├── [...nextauth]/route.ts ← Remplace le placeholder 501 → export { GET, POST } from '@/lib/auth'
    └── login/route.ts        ← POST /api/auth/login (clients API non-browser)

components/auth/
└── LoginForm.tsx             ← Client form (react-hook-form + zodResolver + thème dark/rouge)
```

---

## Composants détaillés

### 1. auth.config.ts — Configuration Edge-safe

Configuration légère utilisée par `proxy.ts`. Ne contient aucune dépendance Node.js lourde (pas de Prisma, pas de bcrypt) pour éviter des connexions DB à chaque requête proxy.

```typescript
// Routes accessibles sans authentification
const PUBLIC_PATHS = ['/login', '/register', '/api/auth', '/api/health', '/api/docs', '/api/swagger', '/api-docs'];

export const authConfig: NextAuthConfig = {
  providers: [],
  session: { strategy: 'jwt' },
  pages: { signIn: '/login' },
  callbacks: {
    authorized({ auth, request }) {
      if (PUBLIC_PATHS.some((p) => pathname.startsWith(p))) return true;
      return !!auth?.user; // Redirige vers /login si non connecté
    },
  },
};
```

**Pourquoi deux configs séparées ?**
- `auth.config.ts` : callback `authorized` uniquement, lu par proxy.ts à chaque requête
- `auth.ts` : config complète avec Credentials provider + Prisma + bcrypt, utilisée lors du sign-in

### 2. auth.ts — NextAuth complet

Le provider Credentials appelle Prisma pour trouver l'utilisateur, puis `bcrypt.compare` pour vérifier le mot de passe.

**Protection contre les timing attacks :**
```typescript
const DUMMY_HASH = '$2b$12$invalidhashpreventstimingattac000000000000000000000000';
// Toujours appeler bcrypt.compare, même si user === null
const ok = await bcrypt.compare(password, user?.password ?? DUMMY_HASH);
```

Sans cette protection, un attaquant pourrait déduire si un username existe ou non en mesurant le temps de réponse.

**Callbacks JWT/session :**
```typescript
jwt({ token, user }) {
  if (user) { token.id = user.id; token.username = user.username; }
  return token;
},
session({ session, token }) {
  session.user.id = token.id;
  session.user.username = token.username;
  return session;
},
```

### 3. types/next-auth.d.ts — Augmentation TypeScript

```typescript
declare module 'next-auth' {
  interface Session {
    user: { id: string; username: string } & DefaultSession['user'];
  }
  interface User { id: string; username: string; createdAt: Date; }
}
declare module 'next-auth/jwt' {
  interface JWT { id: string; username: string; }
}
```

Permet l'accès typé à `session.user.id` et `session.user.username` dans tous les composants.

### 4. proxy.ts — Protection de routes

> **Next.js 16** a renommé `middleware.ts` → `proxy.ts`. La fonction exportée doit s'appeler `proxy` (et non `middleware`). Le runtime est **Node.js** (pas Edge).

```typescript
const { auth } = NextAuth(authConfig);

export const proxy = auth((req: NextRequest) => {
  // Logique CORS + logging + X-Request-Id (héritée de US-01-05)
  return response;
});

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
};
```

Le matcher couvre désormais toutes les routes (pas seulement `/api/*` comme avant), ce qui permet de protéger les pages `/dashboard`, etc.

### 5. loginUser() — Service

```typescript
export async function loginUser(input: LoginInput): Promise<UserPublic> {
  const user = await prisma.user.findUnique({ where: { username: input.username } });
  const isValid = await bcrypt.compare(input.password, user?.password ?? DUMMY_HASH);
  if (!user || !isValid) throw unauthorized(); // 401
  return { id: user.id, username: user.username, createdAt: user.createdAt };
}
```

### 6. Route POST /api/auth/login

Endpoint dédié pour les clients API non-browser (mobile, tests, intégrations) :

```typescript
export const POST = withErrorHandler(
  withValidation(LoginSchema, async (_req, { data }) => {
    const user = await loginUser(data);
    return ApiResponse.success(user, { message: 'Connexion réussie' });
  }),
);
```

### 7. loginAction — Server Action

```typescript
'use server';
export async function loginAction(data: LoginInput) {
  try {
    await signIn('credentials', { ...data, redirectTo: '/' });
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin': return { error: 'Pseudo ou mot de passe incorrect' };
        default: return { error: 'Une erreur est survenue, réessaie.' };
      }
    }
    throw error; // Re-throw NEXT_REDIRECT (success case)
  }
}
```

**Important :** NextAuth lève une erreur `NEXT_REDIRECT` en cas de succès (c'est une redirection). Cette erreur doit être re-thrown et **non** catchée.

### 8. LoginForm

Client component (même thème dark/rouge que RegisterForm) :
- `useForm({ resolver: zodResolver(LoginSchema) })`
- Champs : `username`, `password`
- Appelle `loginAction(values)` via Server Action
- Affiche l'erreur `root` si `result?.error` est défini
- Lien vers `/register`

---

## Flux d'authentification complet

```
1. Utilisateur saisit username + password dans LoginForm
2. handleSubmit → loginAction(values)   [Server Action]
3. loginAction → signIn('credentials', { ...data, redirectTo: '/' })
4. NextAuth → authorize(credentials)    [auth.ts]
5. authorize → prisma.user.findUnique
6. authorize → bcrypt.compare
7. Si OK → retourne { id, username, createdAt }
8. NextAuth encode JWT avec id + username
9. NextAuth set cookie (session)
10. redirect('/') → dashboard
```

Flux pour l'API (clients non-browser) :
```
POST /api/auth/login { username, password }
→ withValidation(LoginSchema)
→ loginUser(data)
→ { success: true, data: { id, username, createdAt } }
```

---

## Décisions techniques

### Pourquoi deux configs NextAuth ?
- `auth.config.ts` (léger) : exécuté à chaque requête par proxy.ts → pas de connexion DB
- `auth.ts` (complet) : exécuté seulement lors du sign-in → peut utiliser Prisma + bcrypt

### Pourquoi bcrypt.compare même si user === null ?
Protection contre les timing attacks. Sans cela, un attaquant peut déduire si un username existe en mesurant les temps de réponse (trouver un user prend plus de temps car bcrypt.compare est lent ~100ms, ne pas trouver serait instantané).

### Pourquoi proxy.ts et non middleware.ts ?
Next.js 16 a renommé le fichier de proxy. `proxy.ts` est automatiquement détecté et exécuté à chaque requête. L'ancienne convention `middleware.ts` est dépréciée (garde compatibilité Edge uniquement).

### Pourquoi un endpoint `/api/auth/login` en plus de NextAuth ?
NextAuth gère l'authentification browser via `/api/auth/callback/credentials`. L'endpoint `/api/auth/login` est destiné aux clients API non-browser (mobile, scripts, tests d'intégration) qui veulent valider des credentials sans session cookie.

---

## Variables d'environnement

| Variable | Description | Requis |
|----------|-------------|--------|
| `AUTH_SECRET` | Secret JWT pour signer les tokens NextAuth | **Oui** |
| `NEXTAUTH_URL` | URL de base de l'application | **Oui** (prod) |
| `DATABASE_URL` | URL PostgreSQL pour Prisma | Oui (existant) |
| `ALLOWED_ORIGINS` | Origines CORS autorisées | Non (défaut: localhost:3000) |

---

## Tests

### Couverture
```
lib/services/auth/authService.ts → 100%
  - registerUser : 7 tests (existants)
  - loginUser    : 4 tests (ajoutés)
```

### Tests loginUser
```typescript
it('retourne UserPublic si identifiants valides')
it('ne retourne jamais le champ password dans UserPublic')
it('lève unauthorized (401) si utilisateur inexistant (timing-safe)')
it('lève unauthorized (401) si mot de passe incorrect')
```

### Commandes
```bash
pnpm test            # 92/92 passent
pnpm test:coverage   # voir la couverture par fichier
```

---

## Vérification manuelle

```bash
pnpm dev

# Page de connexion
open http://localhost:3000/login

# Page d'inscription (existante)
open http://localhost:3000/register

# Endpoint API login
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "ThorinHero", "password": "Password1"}' | jq .

# Routes protégées → redirect /login
curl -I http://localhost:3000/  # → 307 Location: /login (si non connecté)

# TypeScript
pnpm tsc --noEmit   # → 0 erreur
```

---

## Liens avec les autres US

| US | Dépendance |
|----|------------|
| US-01-05 | API infrastructure (withErrorHandler, withValidation, ApiResponse) |
| US-02-01 | RegisterForm, RegisterSchema, registerUser, bcrypt, Prisma |
| US-02-02 | ← Cette US : LoginForm, LoginSchema, loginUser, NextAuth |
