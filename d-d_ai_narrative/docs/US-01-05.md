# US-01-05 — API Routes structurées et documentées

## Vue d'ensemble

Cette US met en place l'infrastructure API du projet D&D AI Narrative : un système d'erreurs typées, des réponses normalisées, des middlewares HOF, des schemas Zod, un healthcheck, des routes placeholder documentées et une spec OpenAPI complète.

---

## Architecture

```
proxy.ts                          ← Intercepteur de requêtes (CORS, logging, X-Request-Id)

lib/
├── api/
│   ├── errors/                   ← Système d'erreurs typées
│   │   ├── AppError.ts           ← Classe de base
│   │   ├── HttpError.ts          ← Factory functions (badRequest, notFound, etc.)
│   │   └── index.ts              ← Barrel export
│   ├── middleware/               ← Higher-Order Functions
│   │   ├── withErrorHandler.ts   ← Intercepte et normalise toutes les erreurs
│   │   ├── withValidation.ts     ← Valide le body JSON avec Zod
│   │   └── index.ts
│   └── response/                 ← Réponses API normalisées
│       ├── ApiResponse.ts        ← success(), created(), error(), paginated()
│       └── index.ts
├── swagger/
│   ├── swaggerConfig.ts          ← Configuration OpenAPI 3.0
│   └── index.ts
└── validations/
    ├── common.ts                 ← PaginationSchema, CuidSchema
    ├── room.ts                   ← CreateRoomSchema, UpdateRoomSchema
    └── character.ts              ← CreateCharacterSchema

app/api/
├── health/route.ts               ← GET /api/health
├── rooms/route.ts                ← GET + POST /api/rooms
├── characters/route.ts           ← GET + POST /api/characters
├── auth/[...nextauth]/route.ts   ← GET + POST /api/auth/*
├── docs/route.ts                 ← GET /api/docs (spec OpenAPI JSON)
└── swagger/route.ts              ← GET /api/swagger (legacy, maintenu)
```

---

## Composants détaillés

### 1. proxy.ts + middleware.ts

**proxy.ts** est le cœur de l'intercepteur de requêtes. Il s'exécute avant chaque route `/api/*` et :

- Génère un `X-Request-Id` unique via `crypto.randomUUID()` pour tracer chaque requête
- Mesure le `X-Response-Time` (approximation du temps de traitement proxy)
- Log chaque requête en JSON structuré : méthode, path, timestamp, requestId
- Gère les headers CORS selon `ALLOWED_ORIGINS` (env var)

**Pourquoi deux fichiers ?**
Next.js reconnaît uniquement `middleware.ts` avec un export nommé `middleware`. Le fichier `middleware.ts` re-exporte simplement `proxy as middleware`, permettant de respecter la spec US qui nomme ce fichier `proxy.ts` tout en conservant la compatibilité Next.js.

```typescript
// middleware.ts — bridge minimal
export { proxy as middleware, config } from './proxy';
```

### 2. Système d'erreurs (lib/api/errors/)

**AppError** est la classe de base pour toutes les erreurs applicatives :

```typescript
class AppError extends Error {
  readonly code: ErrorCode;    // 'NOT_FOUND', 'VALIDATION_ERROR', etc.
  readonly statusCode: number; // 400, 401, 403, 404, 409, 500, 501
  readonly details?: unknown;  // Informations complémentaires (erreurs Zod, etc.)
}
```

**HttpError** expose des factory functions (pas de classes dérivées, SOLID ISP) :

```typescript
import { notFound, badRequest, unauthorized } from '@/lib/api/errors';

throw notFound('Room');         // → 404 "Room not found"
throw badRequest('Invalid ID'); // → 400 "Invalid ID"
throw unauthorized();           // → 401 "Authentication required"
```

**Pourquoi des factory functions plutôt que des classes ?**
- Moins de boilerplate
- Plus lisible à l'usage
- Respecte le principe ISP : chaque erreur est indépendante

### 3. Réponses API normalisées (lib/api/response/)

Toutes les réponses suivent ce format strict, garantissant la prévisibilité côté client :

```json
{
  "success": true,
  "data": { ... },
  "message": "Room created successfully",
  "error": null,
  "meta": {
    "timestamp": "2024-01-15T10:30:00.000Z",
    "requestId": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

En cas d'erreur :
```json
{
  "success": false,
  "data": null,
  "message": "Validation failed",
  "error": {
    "code": "VALIDATION_ERROR",
    "details": {
      "fieldErrors": { "name": ["Name must be at least 3 characters"] },
      "formErrors": []
    }
  },
  "meta": { "timestamp": "...", "requestId": "..." }
}
```

### 4. Middlewares HOF (lib/api/middleware/)

Les middlewares sont des Higher-Order Functions (HOF) qui wrappent les handlers Next.js.

**withErrorHandler** — gestion centralisée des erreurs :

```typescript
export const GET = withErrorHandler(async (req) => {
  // Toute erreur lancée ici est automatiquement capturée
  // AppError → réponse typée avec le bon statusCode
  // Error → log + 500
  // unknown → 500 sans détails exposés
  throw notFound('Room'); // → 404
});
```

**withValidation** — validation Zod du body JSON :

```typescript
export const POST = withErrorHandler(
  withValidation(CreateRoomSchema, async (req, { data }) => {
    // `data` est typé selon CreateRoomSchema
    // Si le body est invalide → 400 avec les erreurs Zod formatées
    return ApiResponse.created(data);
  })
);
```

La composition `withErrorHandler(withValidation(...))` permet de chaîner les middlewares sans imbrication profonde.

### 5. Schemas Zod (lib/validations/)

**common.ts** — schemas réutilisables :
- `PaginationSchema` : valide et coerce les query params `?page=1&limit=20`
- `CuidSchema` : valide les identifiants CUID (format Prisma par défaut)

**room.ts** :
- `CreateRoomSchema` : nom (3-50 car.), description (max 500), maxPlayers (2-8), isPrivate
- `UpdateRoomSchema` : version partielle de CreateRoomSchema (tous les champs optionnels)

**character.ts** :
- `DndRaceSchema` : enum des 9 races D&D classiques
- `DndClassSchema` : enum des 12 classes D&D 5e
- `CreateCharacterSchema` : nom (2-30), race, classe, historique (max 2000), stats (1-20 chacune)

### 6. Configuration OpenAPI (lib/swagger/)

La spec est générée avec `swagger-jsdoc` (déjà présent dans le projet) en scannant les annotations `@openapi` JSDoc dans `app/api/**/*.ts`.

**Fonctionnalités** :
- OpenAPI 3.0.0
- Titre "D&D AI Narrative API" v0.1.0
- Security scheme `BearerAuth` (JWT Bearer)
- Tags : `health`, `auth`, `rooms`, `characters`
- Schema `ApiError` réutilisable dans toutes les routes

### 7. Routes API

#### GET /api/health
Healthcheck complet sans authentification :
- Status global : `healthy` ou `degraded`
- Version de l'application (depuis `npm_package_version`)
- Environnement (`development` | `production`)
- Uptime en secondes
- Checks : base de données (TCP sur DATABASE_URL) + mémoire heap

**Note technique** : Le check database utilise le module `net` de Node.js pour une connexion TCP directe, évitant la dépendance au client Prisma généré. Cela permet au healthcheck de fonctionner même avant `prisma generate`.

#### GET/POST /api/rooms, /api/characters, /api/auth/[...nextauth]
Routes placeholder retournant 501 Not Implemented. Structure HOF prête pour la logique métier :
- Les routes GET sont wrappées avec `withErrorHandler`
- Les routes POST ajoutent `withValidation` avec le schema Zod correspondant
- Toutes sont annotées `@openapi` pour la documentation Swagger

#### GET /api/docs
Retourne la spec OpenAPI complète en JSON. Consommée par `/api-docs` (SwaggerUI existant).

---

## Commandes de test

### Démarrage
```bash
pnpm dev
```

### Healthcheck
```bash
curl http://localhost:3000/api/health | jq .
```

Réponse attendue :
```json
{
  "status": "healthy",
  "version": "0.1.0",
  "environment": "development",
  "timestamp": "2024-01-15T10:30:00.000Z",
  "uptime": 5.234,
  "checks": {
    "database": "degraded",
    "memory": { "usedMb": 45, "totalMb": 120, "percentage": 37 }
  }
}
```

### Validation Zod (test 400)
```bash
curl -X POST http://localhost:3000/api/rooms \
  -H "Content-Type: application/json" \
  -d '{"name": "ab"}' | jq .
```

Réponse attendue (400) :
```json
{
  "success": false,
  "data": null,
  "message": "Validation failed",
  "error": {
    "code": "VALIDATION_ERROR",
    "details": {
      "fieldErrors": {
        "name": ["Name must be at least 3 characters"],
        "maxPlayers": ["Required"],
        "isPrivate": ["Required"]
      },
      "formErrors": []
    }
  }
}
```

### Documentation Swagger
- **JSON** : `curl http://localhost:3000/api/docs`
- **UI** : ouvrir `http://localhost:3000/api-docs` dans le navigateur

---

## Variables d'environnement

Copier `.env.example` en `.env` et remplir les valeurs :

| Variable | Description | Requis |
|----------|-------------|--------|
| `DATABASE_URL` | URL PostgreSQL pour Prisma | Oui |
| `ALLOWED_ORIGINS` | Origines CORS autorisées (séparées par `,`) | Non (défaut: `http://localhost:3000`) |
| `NODE_ENV` | Environnement d'exécution | Non (défaut: `development`) |
| `OPENAI_API_KEY` | Clé API OpenAI (pour les US futures) | Non |
| `NEXTAUTH_SECRET` | Secret NextAuth (pour les US futures) | Non |
| `NEXTAUTH_URL` | URL de l'application (pour les US futures) | Non |

---

## Décisions techniques

### Pourquoi `swagger-jsdoc` et pas `next-swagger-doc` ?
`swagger-jsdoc` est déjà installé dans le projet et fait exactement le même travail. `next-swagger-doc` est un wrapper minimal qui n'apporte aucune fonctionnalité supplémentaire dans ce contexte.

### Pourquoi `net.createConnection` plutôt que Prisma pour le healthcheck ?
Le client Prisma est généré dans `app/generated/prisma` via `prisma generate`. Avant cette étape, le module n'existe pas et TypeScript échouerait. L'approche TCP est :
- Indépendante du client Prisma
- Plus rapide (pas d'ORM overhead)
- TypeScript-safe (module `net` natif)

### Pourquoi des factory functions pour HttpError ?
Conforme SOLID ISP et Clean Code : chaque type d'erreur est créé par une fonction dédiée, lisible et testable indépendamment. Évite la hiérarchie de classes excessive.

### Pourquoi pas de cache sur les routes API ?
Next.js 16 est dynamique par défaut pour les routes API. Aucun `revalidate` ou `cache: 'force-cache'` n'est ajouté intentionnellement — conformément à la spec US-01-05.

---

## Vérification TypeScript

```bash
pnpm tsc --noEmit
# → 0 erreur
```
